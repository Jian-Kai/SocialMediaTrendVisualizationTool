<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        font: 13px sans-serif;
        position: relative;
        width: 960px;
        height: 500px;
    }

    form {
        position: absolute;
        bottom: 10px;
        left: 10px;
    }

    rect {
        fill: none;
        stroke: #ff7f0e;
        pointer-events: all;
    }

    .path {
        fill: none;
    }

    circle,
    .line {
        fill: none;
        stroke: steelblue;
        stroke-width: 1.5px;
    }

    .field {
        fill: none;
        stroke-opacity: 0.4;
        stroke-width: 2.5px;
    }

    circle {
        fill: #fff;
        cursor: move;
    }

    .selected {
        stroke: #ff7f0e;
    }
</style>
<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
<svg id="mainSvg"></svg>

<body>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="./hammer.js" ></script>
    <div style="padding:10px; width:960px; display:inlineblack;">
        <hr>
        <span>拖動Node，和其他Cluster合併。</span>
        </br>
        <span>如果Cluster內的Node與Node距離太近，雙擊Cluster中其中一個Node，以其Node進行擴散。</span>
        </br>
        <span>Shift+滑鼠左鍵可以畫線，將想要切開的Cluster分成兩個Cluster。</span>
        </br>
        <span>Ctrl+滑鼠左鍵拖動Node，可以移動目標Node的當前Cluster。</span>
    </div>
</body>
<script>

    document.body.addEventListener('touchmove', function (event) {
        event.preventDefault();
    }, false);
    // layout
    var nx = 41; //number of arrows in x
    var ny = 25; //number of arrows in y
    var L = 20; //size in pixels of the square containing each arrow

    var line = d3.svg.line();

    //globals
    var atten = 200; //field attenuation factor
    var isOnSvg = false;

    var iconnuber = 20;
    //icon位置
    var icons = d3.range(0, iconnuber).map(function(i) {
        return [parseInt(Math.random() * nx) * L, parseInt(Math.random() * ny) * L, i];
    });
    console.log(icons);

    var Cluster = []; //群
    var Boudary = []; //每個群的邊界以及中心點
    var Field = []; //每一個群在其Boudary所產生的力場
    var path = [];

    var dragged = null;
    var curcluster = null;



    function distance(d) //距離
    {
        return Math.sqrt(Math.pow(d[0], 2) + Math.pow(d[1], 2));
    }

    function remove(arr, tar) //delete
    {
        var lest
        if (tar == arr.length - 1)
            arr.pop();
        else {
            lest = arr.pop();
            arr[tar] = lest;
        }
        return arr;
    }

    function init_marge() {
        Cluster = [];
        Boudary = [];
        for (var l = 0; l < icons.length; l++) {
            Cluster.push([icons[l][2]]);
        }

        for (var i = 0; i < icons.length; i++) {
            for (var j = i; j < icons.length; j++) {
                var dx = icons[i][0] - icons[j][0];
                var dy = icons[i][1] - icons[j][1];
                var dis = distance([dx, dy]);
                var cur, tar;
                if (dis < 35 && dis >= 0) //距離在0和100之間
                {
                    for (var k = 0; k < Cluster.length; k++) //找出兩個點所屬的群的index
                    {
                        for (var n = 0; n < Cluster[k].length; n++) {

                            if (i == Cluster[k][n])
                                cur = k;
                            if (j == Cluster[k][n])
                                tar = k;
                        }
                    }
                    if (cur != tar) //marge起來
                    {
                        for (var o = 0; o < Cluster[tar].length; o++) {
                            Cluster[cur].push(Cluster[tar][o]);
                        }
                        remove(Cluster, tar); //把被marge的群移除
                    }
                }
            }
        }
    }

    function marge() {

        Boudary = [];

        var index = dragged[2];
        var curCluster, pleace;
        //判斷點擊的Node屬於哪一個Cluster
        for (var i = 0; i < Cluster.length; i++) {
            for (var j = 0; j < Cluster[i].length; j++) {
                if (Cluster[i][j] == index) {
                    curCluster = i;
                    pleace = j;
                }
            }
        }

        //separate
        var count = 0;
        for (var i = 0; i <= Cluster[curCluster].length; i++) {
            var curX = icons[index][0],
                curY = icons[index][1];
            if (Cluster[curCluster][i] != index && i != Cluster[curCluster].length) {
                var tarX = icons[Cluster[curCluster][i]][0],
                    tarY = icons[Cluster[curCluster][i]][1];
                var dis = distance([curX - tarX, curY - tarY]);
                if (dis > 35) {
                    count++;
                }
            } else if (i == Cluster[curCluster].length) {
                if (count == Cluster[curCluster].length - 1 && Cluster[curCluster].length != 1) {
                    remove(Cluster[curCluster], pleace);
                    Cluster.push([icons[index][2]]);
                }
            }
        }

        //marge
        var tar = -1;
        stop:
            for (var i = 0; i < Cluster.length; i++) {
                if (i != curCluster) {
                    for (var j = 0; j < Cluster[curCluster].length; j++) {
                        //console.log(Cluster[curCluster].length);
                        var curX = icons[Cluster[curCluster][j]][0],
                            curY = icons[Cluster[curCluster][j]][1];

                        for (var k = 0; k < Cluster[i].length; k++) {
                            var tarX = icons[Cluster[i][k]][0],
                                tarY = icons[Cluster[i][k]][1];
                            var dis = distance([curX - tarX, curY - tarY]);
                            if (dis < 35 && dis >= 0) {
                                tar = i;
                                for (var o = 0; o < Cluster[tar].length; o++) {
                                    Cluster[curCluster].push(Cluster[tar][o]);
                                }
                                // console.log(Cluster[curCluster].length);
                                remove(Cluster, tar); //把被marge的群移除
                                break stop;
                            }
                        }
                    }
                }
            }

        //判斷每一群的Node之間距離是否符合標準
        for (var i = 0; i < Cluster.length; i++) {
            if (Cluster[i].length > 1) {
                for (var j = 0; j < Cluster[i].length; j++) {
                    var curX = icons[Cluster[i][j]][0],
                        curY = icons[Cluster[i][j]][1];
                    var count = 0;
                    var index = icons[Cluster[i][j]][2];
                    for (var k = 0; k < Cluster[i].length; k++) {
                        var tarX = icons[Cluster[i][k]][0],
                            tarY = icons[Cluster[i][k]][1];
                        var dis = distance([curX - tarX, curY - tarY]);
                        if (dis > 35) {
                            count++;
                        }

                        if (count == Cluster[i].length - 1) {
                            remove(Cluster[i], j);
                            Cluster.push([icons[index][2]]);
                        }
                    }
                }
            }
        }

    }

    function Bbox(arr) //找邊界以及中心
    {
        var minX = icons[arr[0]][0],
            minY = icons[arr[0]][1],
            maxX = icons[arr[0]][0],
            maxY = icons[arr[0]][1];
        var cx = 0,
            cy = 0;
        for (var i = 0; i < arr.length; i++) {
            cx += icons[arr[i]][0];
            cy += icons[arr[i]][1];
        }

        for (var i = 1; i < arr.length; i++) {
            var tempX = icons[arr[i]][0],
                tempY = icons[arr[i]][1];
            if (tempX < minX)
                minX = tempX;
            if (tempY < minY)
                minY = tempY;
            if (tempX > maxX)
                maxX = tempX;
            if (tempY > maxY)
                maxY = tempY;
        }

        cx /= arr.length;
        cy /= arr.length;

        return [minX - 20, minY - 20, maxX + 20, maxY + 20, cx, cy];
    }

    var svg = d3.select("#mainSvg")
        .attr("width", nx * L)
        .attr("height", ny * L);

    svg.append("rect")
        .attr("width", nx * L)
        .attr("height", ny * L);

    //Events for drag/add
    d3.select(window)
        .on("mousedown", mousedown)
        .on("mousemove", mousemove)
        .on("mouseup", mouseup);

    //滑鼠事件
    var finger = [];
    function mouseup() {
        //Stop dragging
        if (event.ctrlKey) //ctrl+left
        {
            console.log(dragged);
            dragged = null;
        } else if (event.shiftKey) //shift+left
        {
            drewpath();
        }
    }


    function mousemove() {
        //Drag
        if (event.shiftKey) //shift+left
        {
            var m = d3.mouse(svg.node());
            path.push([Math.max(0, Math.min(nx * L, m[0])), Math.max(0, Math.min(nx * L, m[1]))]);
        } else if (event.ctrlKey) //ctrl+left
        {
            if (!dragged) return;
            var curCluster;
            curCluster = movemerge();
            play();
        }
    }


    function mousedown() {
        if (event.shiftKey) {
            path = [];
            console.log("shift");
        } else if (event.ctrlKey) {
            console.log(dragged);
            console.log("ctrl");
            alert(event.ctrlKey + "123");
        }
    }

    var drag = d3.behavior.drag()
            .on('dragstart', function(d) {
              dragged = d;
            })
            .on('drag', function(d) {
              d3.select(this).attr({
                'cx': dragged[0] = d3.event.x,
                'cy': dragged[1] = d3.event.y,
              });
              play();
            })
            .on('dragend', function(){
              dragged = null;
            });

    //將一個Cluster分割成兩個Cluster
    function drewpath() {
        d3.selectAll(".path").remove();
        //找斜率以及直線方程式
        var sX = path[0][0],
            sY = path[0][1];
        var eX = path[path.length - 1][0],
            eY = path[path.length - 1][1];
        var Slope = (eY - sY) / (eX - sX);
        var center = [path[parseInt(path.length / 2)][0], path[parseInt(path.length / 2)][1]];
        var b = sY - (Slope * sX);

        //判斷直線經過的Cluster
        var curClu = 0;
        var dis = distance([center[0] - Boudary[curClu][4], center[1] - Boudary[curClu][5]]);

        for (var i = 1; i < Boudary.length; i++) {
            if (distance([center[0] - Boudary[i][4], center[1] - Boudary[i][5]]) < dis) {
                dis = distance([center[0] - Boudary[i][4], center[1] - Boudary[i][5]]);
                curClu = i;
            }
        }

        //開始分割
        if (Cluster[curClu].length > 1) //Cluster內Node個數必須大於1
        {
            console.log("/");
            var temp = [];
            for (var i = 0; i < Cluster[curClu].length; i++) {
                //console.log(i);
                var X = (icons[Cluster[curClu][i]][1] - b) / Slope;
                var index = Cluster[curClu][i];

                if (icons[Cluster[curClu][i]][0] - X > 0) //X座標差大於0，分割
                {
                    remove(Cluster[curClu], i);
                    temp.push(index);
                    icons[index][0] += (icons[index][0] - X) / (Math.abs((icons[index][0] - X))) * 1.5;
                    console.log(icons[index]);
                    i--;
                }
            }
            if (temp.length != 0) {
                //console.log(temp);
                Cluster.push(temp);
                //console.log(Cluster);
            }

            Boudary = [];
            for (var i = 0; i < Cluster.length; i++) //根據每個群去找Boudary
            {
                Boudary.push(Bbox(Cluster[i]));
            }
            //console.log(Boudary);
            drewcircle();
            redraw();
        }

        svg
            .append("path")
            .datum(path)
            .attr("class", "path")
            .attr("d", line)
            .attr("y", 0)
            .style({
                "stroke": "#ff7f0e",
                "stroke-width": "5px"
            });
    }


    //根據Boudary大小，劃出對應Cluster的field
    function redraw() {
        d3.selectAll(".field").remove();
        d3.selectAll(".path").remove();

        var l = L / 2;

        for (var o = 0; o < Cluster.length; o++) {
            var box = Boudary[o],
                cluster = Cluster[o];

            var dx = (box[2] - box[0]) / l,
                dy = (box[3] - box[1]) / l;

            var minx = box[0],
                miny = box[1];

            //Draw the surfaces
            var fieldFilled = d3.range(0, dx).map(function() {
                return d3.range(0, dy).map(function(i) {
                    return false;
                })
            });

            var charges = [];
            for (var i = 0; i < cluster.length; i++) {
                charges.push([icons[cluster[i]][0], icons[cluster[i]][1]]);
            }
            //create a path here
            //Define the center of the current block as a starting point of the surface
            var curX = 0 * l + l / 2 + minx;
            var curY = 0 * l + l / 2 + miny;

            var direction = 1; //1 or -1
            var dots = [];
            dots.push([curX + L / 2, curY + L / 2]);

            //Superposition the fields from all charges, and get the resulting force vector
            var dirX = 0;
            var dirY = 0;
            var totalForce = 0;
            for (var j = 0; j < charges.length; j++) {
                var distX = curX - charges[j][0];
                var distY = curY - charges[j][1];
                var distanceSq = distX * distX + distY * distY;
                var force = 5 / distanceSq;

                var distanceFactor = force / Math.sqrt(distanceSq);

                //Measure the initial force in order to match the equipotential surface points
                //計算力場
                totalForce += force;
                dirX += distX * distanceFactor;
                dirY += distY * distanceFactor;
            }

            //dots per surface line
            var times = 500;
            while (times-- > 0) {

                var dirTotal = Math.sqrt(dirX * dirX + dirY * dirY);
                var stepX = dirX / dirTotal;
                var stepY = dirY / dirTotal;
                //The equipotential surface moves normal to the force vector
                curX = curX + direction * 6 * stepY;
                curY = curY - direction * 6 * stepX;

                //Correct the exact point a bit to match the initial force as near it can
                var minForceIndex = -1;
                var minForceDiff = 0;
                var minDirX = 0;
                var minDirY = 0;
                var minCurX = 0;
                var minCurY = 0;

                curX -= 3 * stepX;
                curY -= 3 * stepY;

                for (var pointIndex = 0; pointIndex < 4; pointIndex++, curX += stepX, curY += stepY) {
                    dirX = 0;
                    dirY = 0;

                    var forceSum = 0;
                    for (var j = 0; j < charges.length; j++) {
                        var distX = curX - charges[j][0];
                        var distY = curY - charges[j][1];
                        var distanceSq = distX * distX + distY * distY;
                        var force = 5 / distanceSq;

                        var distanceFactor = force / Math.sqrt(distanceSq);

                        //Measure the initial force in order to match the equipotential surface points
                        forceSum += force;
                        dirX += distX * distanceFactor;
                        dirY += distY * distanceFactor;
                    }

                    var forceDiff = Math.abs(forceSum - totalForce);

                    if (minForceIndex == -1 || forceDiff < minForceDiff) {
                        minForceIndex = pointIndex;
                        minForceDiff = forceDiff;
                        minDirX = dirX;
                        minDirY = dirY;
                        minCurX = curX;
                        minCurY = curY;
                    } else {
                        break;
                    }
                }

                //Set the corrected equipotential point
                curX = minCurX;
                curY = minCurY;
                dirX = minDirX;
                dirY = minDirY;
                //Add the dot to the line
                dots.push([curX + L / 2, curY + L / 2]);
            }

            //var pair = dots;

            svg
                .append("path")
                .datum(dots)
                .attr("class", "field")
                .attr("d", line)
                .attr("y", 0)
                .style({
                    "stroke": "#ff7f0e",
                    "stroke-width": "5px"
                });
        }
    }


    function display() {
        init_marge();

        for (var i = 0; i < Cluster.length; i++) //根據每個群去找Boudary
        {
            Boudary.push(Bbox(Cluster[i]));
        }

        redraw();
        drewcircle();
    }

    function play() {
        marge();

        for (var i = 0; i < Cluster.length; i++) //根據每個群去找Boudary
        {
            Boudary.push(Bbox(Cluster[i]));
        }

        redraw();
        drewcircle();
    }

    //畫Node
    function drewcircle() {
        var circle = svg.selectAll("circle")
            .data(icons);

        circle
            .attr('cx', function(d) {
                return d[0] + L / 2;
            })
            .attr('cy', function(d) {
                return d[1] + L / 2;
            })
            .attr('r', L / 2)
            .style('fill', '#58ACFA');

        circle
            .enter()
            .append('circle')
            .attr('cx', function(d) {
                return d[0] + L / 2;
            })
            .attr('cy', function(d) {
                return d[1] + L / 2;
            })
            .attr('r', L / 2)
            .style('fill', '#58ACFA')
            .call(drag) //D3 drag
            .each(function(d, i){  //hammer 手勢
          		addHummerEventListener(this, d);
          	});
        circle.exit().remove();
    }

    function addHummerEventListener(that, d){
      Hammer(that).on("doubletap", function(event){
        dragged = d;
        console.log(dragged);
        Spreadcluster()
        console.log("DTap! ["+d[0]+ "," + d[1] + "]");
    	});
    }


    /*  Hammer(mainSvg).on("pan", function(event){
        var m = [event.center.x, event.center.y];
        console.log(m);
        path.push([Math.max(0, Math.min(nx * L, m[0])), Math.max(0, Math.min(nx * L, m[1]))]);
      });
      Hammer(mainSvg).on("panend", function(event){
        drewpath();
        path = [];
      });*/

    //擴散Cluster
    function Spreadcluster() {
        var index = dragged[2];
        var curCluster;
        //判斷點擊的Node屬於哪一個Cluster
        for (var i = 0; i < Cluster.length; i++) {
            for (var j = 0; j < Cluster[i].length; j++) {
                if (Cluster[i][j] == index) {
                    curCluster = i;
                }
            }
        }
        //console.log(Cluster[curCluster].length);

        var temp = []; //紀錄原始位置

        //開始擴散
        for (var i = 0; i < Cluster[curCluster].length; i++) {
            var dx, dy;
            //存原始位置
            temp.push([icons[Cluster[curCluster][i]][0], icons[Cluster[curCluster][i]][1], icons[Cluster[curCluster][i]][2]]);
        }

        for (var cycle = 0; cycle < 2; cycle++) {
            for (var i = 0; i < Cluster[curCluster].length; i++) {
                var intx = icons[Cluster[curCluster][i]][0],
                    inty = icons[Cluster[curCluster][i]][1];
                for (var j = 0; j < Cluster[curCluster].length; j++) {

                    var dx = icons[Cluster[curCluster][j]][0] - intx,
                        dy = icons[Cluster[curCluster][j]][1] - inty;

                    if (i != j && distance([dx, dy]) <= 20 && Cluster[curCluster][j] != index) {
                        /*console.log("20"+icons[Cluster[curCluster][i]]);
                        console.log("20"+icons[Cluster[curCluster][j]]);*/
                         console.log(distance([dx, dy]));

                        if (dx != 0) {
                            dx = (dx / Math.abs(dx));
                        }

                        if (dy != 0) {
                            dy = (dy / Math.abs(dy));
                        }
                        icons[Cluster[curCluster][j]][0] += dx * 10;
                        icons[Cluster[curCluster][j]][1] += dy * 10;
                    }

                }
            }
        }



        Boudary[curCluster] = Bbox(Cluster[curCluster]);

        redraw();
        drewcircle();

        //還原原始位置
        for (var i = 0; i < temp.length; i++) {
            icons[Cluster[curCluster][i]][0] = temp[i][0];
            icons[Cluster[curCluster][i]][1] = temp[i][1];
        }
        Boudary[curCluster] = Bbox(Cluster[curCluster]);

    }

    function movemerge() {
        var index = dragged[2];
        var intX = dragged[0],
            intY = dragged[1];
        var curCluster;
        //判斷點擊的Node屬於哪一個Cluster
        for (var i = 0; i < Cluster.length; i++) {
            for (var j = 0; j < Cluster[i].length; j++) {
                if (Cluster[i][j] == index) {
                    curCluster = i;
                }
            }
        }

        var m = d3.mouse(svg.node());
        dragged[0] = Math.max(0, Math.min(nx * L, m[0]));
        dragged[1] = Math.max(0, Math.min(ny * L, m[1]));

        var dx = dragged[0] - intX,
            dy = dragged[1] - intY;

        //同一Cluster一起移動
        for (var i = 0; i < Cluster[curCluster].length; i++) {
            if (icons[Cluster[curCluster][i]][2] != index) {
                icons[Cluster[curCluster][i]][0] += dx;
                icons[Cluster[curCluster][i]][1] += dy;
            }
        }

        return curCluster;

    }

    display();
</script>
